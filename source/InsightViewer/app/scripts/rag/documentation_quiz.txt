```python
// filepath: /home/robert/insightViewer/source/InsightViewer/app/scripts/rag/rag_chat_api_v3.py
ASSESSABLE_CYPHER = """
MATCH (a:Article {projectName:$projectName})
WHERE $articleNum IS NULL OR a.num = $articleNum
MATCH (a)-[:HAS_PARAGRAPH]->(p:Paragraph {projectName:$projectName})
OPTIONAL MATCH (p)-[:HAS_POINT]->(pt:Point {projectName:$projectName})
OPTIONAL MATCH (p)-[:HAS_ITEM]->(ip:IndentItem {projectName:$projectName})
OPTIONAL MATCH (pt)-[:HAS_ITEM]->(it:IndentItem {projectName:$projectName})

WITH collect(p) + collect(pt) + collect(ip) + collect(it) AS baseNodes
UNWIND baseNodes AS n
WITH DISTINCT n
WHERE n.isAssessable = "true" AND n.text IS NOT NULL

OPTIONAL MATCH (c:Chunk)-[:CHUNK_OF]->(n)

RETURN DISTINCT
  n.text AS node_text,
  c.text AS chunk_text
"""
```

Opomba:

- zgornji primer predpostavlja, da `Paragraph`, `Point`, `IndentItem`, `Chunk` imajo property `isAssessable` in `text`.
- če imaš Chunks vedno vezane z `(:Chunk)-[:CHUNK_OF]->(anyNodeWithText)`, lahko query poenostaviš:
  
```cypher
MATCH (n {projectName:$projectName})
WHERE n.isAssessable = "true" AND n.text is not null
RETURN n.text AS txt
```

in ga omejiš po členu z `Article` → `Paragraph` → …

Za začetek predlagam preprost query, npr.:

````python
```python
// filepath: /home/robert/insightViewer/source/InsightViewer/app/scripts/rag/rag_chat_api_v3.py
ASSESSABLE_CYPHER = """
MATCH (a:Article {projectName:$projectName})
WHERE $articleNum IS NULL OR a.num = $articleNum
MATCH (a)-[:HAS_PARAGRAPH]->(p:Paragraph {projectName:$projectName})
OPTIONAL MATCH (p)-[:HAS_POINT]->(pt:Point {projectName:$projectName})
OPTIONAL MATCH (p)-[:HAS_ITEM]->(ip:IndentItem {projectName:$projectName})
OPTIONAL MATCH (pt)-[:HAS_ITEM]->(it:IndentItem {projectName:$projectName})
WITH collect(p) + collect(pt) + collect(ip) + collect(it) AS ns
UNWIND ns AS n
WITH DISTINCT n
WHERE n.isAssessable = "true" AND n.text is not null
RETURN n.text AS txt
"""
```

### 2.3. Prompt za ocenjevanje odgovora

Dodaj helper:

````python
```python
// filepath: /home/robert/insightViewer/source/InsightViewer/app/scripts/rag/rag_chat_api_v3.py
def build_grading_prompt(question: str, user_answer: str, context_chunks: List[str]) -> str:
    ctx = "\n\n".join(context_chunks[:20])  # omejiš število blokov, če jih je veliko
    lines = []
    lines.append("Si natančen pravni asistent za ZGD-1 (Slovenija).")
    lines.append("Tvoja naloga je OVREDNOTITI odgovor študenta glede na podan kontekst.")
    lines.append("Najprej na kratko zapiši, ali je odgovor pravilen, delno pravilen ali napačen ter podaj dosežene točke od 1 do 10")
    lines.append("Nato podaj razlago, katere ključne elemente je zajel")
    lines.append("V primeru da odgovor ni popoln ga napoti na ustrezen člen zakona in paragraph")
    lines.append("Odgovarjaj v slovenščini.")
    lines.append("")
    lines.append("KONTEKST (iz zakona, vozlišča isAssessable=true):")
    lines.append(ctx if ctx else "(Ni konteksta.)")
    lines.append("")
    lines.append(f"VPRAŠANJE: {question}")
    lines.append("")
    lines.append(f"ODGOVOR ŠTUDENTA: {user_answer}")
    lines.append("")
    lines.append("OCENA IN RAZLAGA:")
    return "\n".join(lines)
```

### 2.4. Endpoint `/grade-answer`

Na dno datoteke, poleg `/chat`, dodaj:

````python
```python
// filepath: /home/robert/insightViewer/source/InsightViewer/app/scripts/rag/rag_chat_api_v3.py
@app.post("/grade-answer", response_model=GradeResponse)
def grade_answer(req: GradeRequest):
    question = (req.question or "").strip()
    user_answer = (req.user_answer or "").strip()
    if not question or not user_answer:
        raise HTTPException(status_code=400, detail="question and user_answer are required")

    # po želji, če imaš hint na člen, ga uporabiš
    article_num = req.article_num

    # 1) poberi kontekst iz Neo4j (samo isAssessable=true)
    with driver.session() as session:
        rows = list(session.run(
            ASSESSABLE_CYPHER,
            projectName=PROJECT,
            articleNum=article_num,
        ))
    context_chunks = [r["txt"] for r in rows if r["txt"]]

    # 2) zgradi prompt za Ollama
    prompt = build_grading_prompt(question, user_answer, context_chunks)

    # 3) pokliči Ollama
    evaluation = ollama_generate(prompt)

    return GradeResponse(evaluation=evaluation)
```

---

## 3. Potek uporabe

1. Zaženeš FastAPI:

   ```bash
   cd /home/robert/insightViewer/source/InsightViewer
   source .venv/bin/activate
   uvicorn app.scripts.rag.rag_chat_api_v3:app --reload --port 8002
   ```

2. Odpreš `assessment.html` v brskalniku (lahko kot file ali preko tvojega web strežnika).

3. Uporabnik izbere vprašanje (v našem primeru avtomatsko prvo), vpiše odgovor in klikne “Preveri odgovor”.

4. Frontend naredi:

   ```http
   POST http://localhost:8002/grade-answer
   {
     "question": "...",
     "user_answer": "..."
   }
   ```

5. Backend:
   - iz Neo4j pobere vse [text](http://_vscodecontentref_/7) iz vozlišč, kjer je `isAssessable = true` (po možnosti omejeno na določen člen),
   - zgradi prompt,
   - pošlje na Ollama,
   - vrne razlago pravilnosti.

6. Frontend prikaže `evaluation` v sivem polju.

---

Če želiš, lahko naslednji korak naredimo bolj natančen:

- specificirava točen Cypher (`MATCH`) za tvojo shemo (kako shranjuješ `isAssessable` in `Chunk`),
- dodaš `article_num` kot skriti parameter pri vsakem vprašanju (npr. vsi tvoji primeri so iz člena 57.) in ga pošlješ v `GradeRequest`.

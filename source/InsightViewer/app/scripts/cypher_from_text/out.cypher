// NOTE: This script expects parameters: projectName, nodes, rels
// Run via cypher-shell with --param or from driver. If you want a pure .cypher without params, tell me.
// --- Generated by build_cypher_from_text.py ---
// Project: Geografija

// Constraints / Indexes
CREATE CONSTRAINT chapter_key_unique    IF NOT EXISTS FOR (n:Chapter)    REQUIRE n.key IS UNIQUE;
CREATE CONSTRAINT section_key_unique    IF NOT EXISTS FOR (n:Section)    REQUIRE n.key IS UNIQUE;
CREATE CONSTRAINT subsection_key_unique IF NOT EXISTS FOR (n:SubSection) REQUIRE n.key IS UNIQUE;
CREATE CONSTRAINT chunk_key_unique      IF NOT EXISTS FOR (n:Chunk)      REQUIRE n.key IS UNIQUE;
CREATE CONSTRAINT chapter_idrc_unique    IF NOT EXISTS FOR (n:Chapter)    REQUIRE n.id_rc IS UNIQUE;
CREATE CONSTRAINT section_idrc_unique    IF NOT EXISTS FOR (n:Section)    REQUIRE n.id_rc IS UNIQUE;
CREATE CONSTRAINT subsection_idrc_unique IF NOT EXISTS FOR (n:SubSection) REQUIRE n.id_rc IS UNIQUE;
CREATE CONSTRAINT chunk_idrc_unique      IF NOT EXISTS FOR (n:Chunk)      REQUIRE n.id_rc IS UNIQUE;
CREATE INDEX chapter_projectName    IF NOT EXISTS FOR (n:Chapter)    ON (n.projectName);
CREATE INDEX section_projectName    IF NOT EXISTS FOR (n:Section)    ON (n.projectName);
CREATE INDEX subsection_projectName IF NOT EXISTS FOR (n:SubSection) ON (n.projectName);
CREATE INDEX chunk_projectName      IF NOT EXISTS FOR (n:Chunk)      ON (n.projectName);

// Nodes
WITH $projectName AS projectName
UNWIND $nodes AS row
CALL {
  WITH projectName, row
  // Merge by key so reruns are idempotent
  MERGE (n {key: row.key})
  ON CREATE SET n.id_rc = randomUUID()
  SET n.projectName = projectName,
      n.name = row.name
  // Set single label (Chapter / Section / Chunk)
  WITH n, row
  CALL apoc.create.setLabels(n, [row.label]) YIELD node
  WITH node, row
  // Optional properties
  SET node.sid       = row.sid
  FOREACH (_ IN CASE WHEN row.title IS NULL THEN [] ELSE [1] END | SET node.title = row.title)
  FOREACH (_ IN CASE WHEN row.pageStart IS NULL THEN [] ELSE [1] END | SET node.pageStart = row.pageStart)
  FOREACH (_ IN CASE WHEN row.order IS NULL THEN [] ELSE [1] END | SET node.order = row.order)
  FOREACH (_ IN CASE WHEN row.text IS NULL THEN [] ELSE [1] END | SET node.text = row.text)
  RETURN 1 AS ok
}
RETURN count(*) AS nodes_processed;

// Relationships
WITH $rels AS rels
UNWIND rels AS r
MATCH (a {key: r.fromKey})
MATCH (b {key: r.toKey})
CALL {
  WITH a, b, r
  // Dynamic relationship type requires APOC
  CALL apoc.create.relationship(a, r.type, {}, b) YIELD rel
  RETURN 1 AS ok
}
RETURN count(*) AS rels_processed;
